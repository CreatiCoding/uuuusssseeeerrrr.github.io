<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>잊을것 같으면 블로그</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="잊을것 같으면 블로그">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="잊을것 같으면 블로그">
<meta property="og:locale" content="ko-kr">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="잊을것 같으면 블로그">
  
    <link rel="alternate" href="/atom.xml" title="잊을것 같으면 블로그" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">잊을것 같으면 블로그</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-typescript/day1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/12/typescript/day1/" class="article-date">
  <time datetime="2019-01-11T15:00:00.000Z" itemprop="datePublished">2019-01-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/TypeScript/">TypeScript</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/12/typescript/day1/">타입스크립트 1</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>책 : 타입스크립트 퀵스타트</p>
<h2 id="ECMA스크립트-이론"><a href="#ECMA스크립트-이론" class="headerlink" title="ECMA스크립트 이론"></a>ECMA스크립트 이론</h2><p>ECMA = 유럽 컴퓨터 제조사 연합의 약자로 스크립트의 표준을 만들고 관리하는 단체로 스크립트 외 C#이나 다트 등의 언어표준과 JSON, XML등의 데이터 교환 표준도 관리하고 있습니다.</p>
<p>ECMA 스크립트 발전연도</p>
<ul>
<li>1997 : ES1</li>
<li>1998 : ES2</li>
<li>1999 : ES3</li>
<li>2008 : ES4</li>
<li>2009 : ES5</li>
<li>2013 : ES6(ES2015)</li>
<li>2016 : ES7(ES2016)</li>
<li>2017 : ES8(ES2017)</li>
<li>2018 : ES9(ES2018)</li>
</ul>
<h2 id="타입스크립트"><a href="#타입스크립트" class="headerlink" title="타입스크립트"></a>타입스크립트</h2><p>MS에서 개발하고 관리하는 오픈소스 프로그래밍 언어로 브라우저, OS등에 상관없이 동작합니다.<br>자바스크립트의 상위 호환으로 ECMA스크립트의 최신 표준을 지원하며 자바스크립트를 보완해 변수나 함수 등에 명시적으로 타입을 명시해 안전성을 높이고 모듈화, 객체지향등 최신 트렌드도 충분히 따를 수 있도록 합니다.</p>
<h3 id="역사"><a href="#역사" class="headerlink" title="역사"></a>역사</h3><p>자바스크립트는 대규모 어플리케이션을 개발하는 데 있어 불편하다는 불만에 대응하기 위한 목적으로 발명되었습니다.<br>델파이의 창시자이자 C# 언어의 설계를 맡고 있는 앤더스 헤일스버그라는 사람이 이끌고 있습니다. 그 외 난다긴다하는 수많은 사람들이 함께하고 있습니다.</p>
<p>2012년 10월에 첫 출시되어 ECMA스크립트 발표 주기에 맞춰 빠르게 업데이트하면서 최신으로 항상 유지하고 있으며 2014년에 타입스크립트 만을 위한 컴파일러가 등장했으며 2.x부터 서드파티 라이브러리를 쉽게 사용할 수 있도록 개선되어졌습니다.<br>그리고 자바스크립트의 보완 도구로써뿐 아니라 개발을 지원하는 각종 환경(컴파일러 타입 검사, ES5, ES3 하위호환성 등)도 계속 지원하고 있습니다.</p>
<h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><p>동적 언어인 자바스크립트와 달리 정적 언어기 때문에 시간은 들지만 안전성을 보장합니다.<br>정확히 말하면 타입 안전성을 갖는 타입스크립트를 컴파일하면 자바스크립트로 변화하기 때문에 안전성과 속도 두 가지를 전부 잡았다고 볼 수 있습니다.<br>즉, 자바스크립트를 완전히 대체할 수는 없으나 보완하는 역할로 쓰고 있습니다.</p>
<blockquote>
<p>TypeScript = JavaScript + Type</p>
</blockquote>
<p>확장된 자바스크립트로써 모듈화, 객체지향, 구조화등 대규모 어플리케이션을 만들 수 있도록 여러가지를 갖추고 있습니다.</p>
<ul>
<li>모듈과 네임스페이스 지원</li>
</ul>
<p>모듈을 선언하거나 호출할 수 있도록 하는 방식을 지원합니다.<br>변수 -&gt; 함수 -&gt; 클래스로 원하는 크기에 맞춰 사용할 수 있으며 영역 구분을 위해 네임스페이스를 지원합니다.</p>
<ul>
<li>클래스와 네임스페이스 지원</li>
</ul>
<p>ES6의 클래스 기능에 덧붙여 인터페이스를 지원하으로써 객체지향 프로그래밍 환경을 제공합니다.<br>이러한 특징으로 인해 평소 익숙한 자바나 C#등과 같은방식으로 프로그래밍 할 수 있습니다.(interface, implements, extends …)</p>
<p>기존 언어와 차이점은 다음과 같습니다.</p>
<ul>
<li>ES6에 없던 인터페이스를 지원합니다.</li>
<li>자바는 다중 생성자를 선언할 수 있지만 타입스크립트는 하나만 지원합니다.</li>
<li>타입스크립트는 자바와 달리 디폴트 초기화 매개변수와 선택 매개변수를 선언할 수 있습니다.</li>
</ul>
<ul>
<li>타입 시스템 지원</li>
</ul>
<p>실행시 변수 타입이 선언되던 JS와 달리 엄격한 타입을 지정하여 특정한 타입만 받을 수 있도록 합니다.<br>string으로 선언하면 무조건 string만 받을 수 있습니다.</p>
<p>만약 string으로 컴파일하게 되면 타입검사 -&gt; 어노테이션 제거 -&gt; 자바스크립트 변수로 출력하는 과정을 거치게 됩니다. 그리고 변수가 의도한 타입이 아닐 경우 이를 체크하기 위해 필요했던 루틴을 제거하여 성능이나 코드상의 이득을 볼 수 있습니다.</p>
<h3 id="아키텍처"><a href="#아키텍처" class="headerlink" title="아키텍처"></a>아키텍처</h3><p>언어를 좀 더 이해하려면 아키텍처를 볼 필요가 있다고 합니다. 전체 아키텍처는 다음과 같습니다.</p>
<p><img src="https://raw.githubusercontent.com/wiki/Microsoft/TypeScript/images/architecture.png" alt="Architectural overview."></p>
<ul>
<li>코어 타입스크립트 컴파일러</li>
</ul>
<p>타입스크립트 아키텍처는 언어 변환 기능을 수행하는 코어 타입스크립트 컴파일러를 기반으로 합니다.</p>
<p>이 컴파일러는 파서, 바인더, 타입체커, 에미터, 전처리기로 구성되어 있습니다.</p>
<ul>
<li>파서 : 소스코드를 해석해 구문 트리를 만들고 이걸 해석해 중복 내용을 제거한 추상 구문트리를 만듭니다.</li>
<li>바인더 : 인터페이스나 모듈등에 선언이 있을 때 이러한 선언을 심벌(symbol)로 보고 규칙을 정의합니다.</li>
<li>타입 체커 : 타입이 적절한지 체크하고 구문을 분석합니다.</li>
<li>에미터 : <em>.js -&gt; </em>.js, <em>.d.ts, </em>.js.map</li>
<li>전처리기 : 파일에 선언된 import문이나 <code>&lt;reference path=경로&gt;</code>등의 외부 호출 선언이 있을 때 파일을 가져와 파일목록을 생성합니다. 즉, 컴파일러는 전처리기에서 가져온 파일을 이용해 컴파일을 수행합니다.</li>
</ul>
<ul>
<li>언어 서비스</li>
</ul>
<p>코드를 컴파일해서 편집기에서 필요한 기능을 제공합니다.</p>
<ul>
<li>독립 서버</li>
</ul>
<p>컴파일러와 언어 서비스 같은 하위 레이어를 래핑해서 JSON 형식을 통해 외부에 정보를 노출할 수 있게 합니다.<br>tsserver로 불리며 응용 개발에서는 직접 다룰일이 없으며 플러그인을 개발할 때 사용할 수 있습니다.</p>
<ul>
<li>편집기</li>
</ul>
<p>하위 레이어의 요소를 모두 고려해 동작하는 최종 응용 단계의 어플리케이션입니다.</p>
<ul>
<li>컴파일러</li>
</ul>
<ul>
<li>컴파일링 : 한 언어의 소스코드를 다른 언어로 바꾸는 것</li>
<li>트랜스파일링 : 한 언어의 소스코드를 비슷한 추상화 수준의 다른 언어로 바꾸는 것</li>
</ul>
<p>타입스크립트의 경우 자바스크립트로 바꾸니까 컴파일이라고도 할 수 있지만 같은 추상화 수준의 자바스크립트로도 바꾸기 때문에 트랜스파일링이라고도 할 수 있습니다.<br>대부분 많이 쓰는 언어인 컴파일러를 주로 사용하는 편입니다.</p>
<p>호출자는 <code>tsc</code>를 호출하여 사용할 수 있습니다.</p>
<h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p>먼저 node.js를 능력껏 설치합니다.</p>
<p>그리고 콘솔창을 출력해서 다음과 같이 입력합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>버전확인은 다음과 같이 합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc -v</span><br></pre></td></tr></table></figure>
<p>업데이트는 npm을 사용해 다음과 같이 설치합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm outdated -g typescript</span><br></pre></td></tr></table></figure>
<p>타입스크립트의 확장자는 .ts이며 컴파일은 다음과 같이 진행합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc 파일명.ts</span><br></pre></td></tr></table></figure>
<p>컴파일하면 js파일이 생성되기 때문에 실행의 경우 <code>node 파일명.js</code>로 하시면 됩니다.</p>
<p>만약, 바벨을 이용한 하위 스크립트로 변환하기 위해서는 다음과 같이 사용합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc 파일명.ts -t 버전명</span><br></pre></td></tr></table></figure>
<p>버전명에는 ES3, 5, 6, 2016, 2017, Next(항상최신버전)등을 사용할 수 있습니다. 기본값은 ES3 입니다.</p>
<h3 id="tsconfig-json"><a href="#tsconfig-json" class="headerlink" title="tsconfig.json"></a>tsconfig.json</h3><p>프로젝트가 커지다 보면 어떤 특징을 이용해 컴파일하는지 각종 설정 등 복잡해 지는 경우가 많습니다.<br>그래서 tsconfig.json을 사용하여 보관하면 편하게 컴파일 할 수 있습니다.</p>
<p>중요한점은 tsconfig.json이 있는 폴더가 루트폴더가 되기 때문에 경로 설정에 주의하도록 합니다.<br>초기 파일생성은 <code>tsc --init</code>으로 간단하게 만들 수 있습니다. 만들게 되면 몇가지 옵션이 보이는데 책에 나와 있는 옵션은 다음과 같습니다.</p>
<ul>
<li>sourceMap : 컴파일 후 맵파일의 생성여부 설정</li>
<li>strict : 엄격 타입 검사 모드 설정</li>
<li>noImplicitAny : any 타입으로 암묵적 형변환 여부를 결정</li>
<li>esModuleInterop : ECMA스크립트 모듈과 상호 운용성을 가능하게 하는 속성으로 true면 CommonJS모듈을 디폴트 처럼 호출할 수 있습니다.</li>
</ul>
<p>나머지는 Docs를 찾아봅시다..</p>
<h2 id="변수와-기본타입"><a href="#변수와-기본타입" class="headerlink" title="변수와 기본타입"></a>변수와 기본타입</h2><h3 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h3><p>js의 var를 사용합니다만 뒤에 타입이 붙습니다. 기본사용법은 다음과 같습니다 : </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var(let,const) 변수명: 타입명 = &apos;값&apos;;</span><br></pre></td></tr></table></figure>
<p>예를 들면 <code>let myNickName: string = &#39;happy&#39;;</code>와 같이 쓰면 되겠습니다.</p>
<p>존재하는 타입은 기본, 객체, 기타 타입을 지원합니다.<br>기본 타입의 경우 string, number ,boolean, symbol, enum, 문자열 리터럴이 존재합니다.<br>객체 타입의 경우 Array, Tuple, Function, Constructor(생성자), Class, Interface가 존재합니다.<br>기타 타입의 경우 union, intersection, 특수 타입이 존재합니다.</p>
<p>위의 타입 외 변형된 타입도 존재하며 나중에 배울 것입니다.</p>
<h3 id="기본타입"><a href="#기본타입" class="headerlink" title="기본타입"></a>기본타입</h3><p>자바스크립트타입 포함 여러 가지 타입을 지원합니다.</p>
<ul>
<li>Symbol</li>
</ul>
<p>ES6에서 추가된 기능으로써 객체 속성(프로퍼티)의 유일한 식별자로 사용됩니다.</p>
<ul>
<li>enum</li>
</ul>
<p>자바나 C#의 enum과 비슷합니다. 초기값으로 타입스크립트 2.4부터는 문자열도 할당이 가능합니다.</p>
<ul>
<li>any</li>
</ul>
<p>제약이 없는 타입으로 어떤 타입의 값도 받을 수 있습니다. 그래서 타입의 결과를 예측할 수 없을 때 사용하면 유연한 대응을 할 수 있습니다.<br>자바나 C#의 <code>object</code>와 같다고 보시면 되겠습니다.</p>
<p>JS의 Object는 컴파일 시점에 속성의 유무를 검사하지만 any 타입은 런타임 시점에 검사합니다.</p>
<p>반드시 타입을 지정해야 한다면 <code>noImplicitAny</code>를 true로 선언하여 암묵적 형변환을 방지할 수 있습니다.</p>
<ul>
<li>array</li>
</ul>
<p>JS에서 기본적으로 사용하는 배열입니다. <code>let fruits: string[]</code>으로 사용하며 any가 와서 모든 타입을 받을 수 있습니다만 조금 제약하려면 <code>number | string | boolean</code>같은 유니언 타입으로 제약을 할 수 있습니다.</p>
<ul>
<li>Generic</li>
</ul>
<p>Array<t>의 형식으로 선언하며 나중에 좀 더 자세히 배울것입니다.<br>배열과 달리 내장 타입 외 객체타입도 받을 수 있습니다. 배열 요소로 익명함수를 받으려면 람다식을 사용해 편하게 <code>let nums: Array&lt;() =&gt; string&gt;</code> 같은 방식으로 받을 수 있습니다.</t></p>
<ul>
<li>Tuple</li>
</ul>
<p>n개의 요소가 이뤄진 배열에 대응하는 타입을 의미합니다. 특정 n개에 대해 타입을 강제할 수 있으며 간단히 예를 들어 보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let a = [string, number]=[&quot;tuple&quot;, number, 문자나 숫자...]</span><br></pre></td></tr></table></figure>
<p>대충 이런 식이 있다고 했을 때 우측 값배열의 첫 번째는 튜플의 첫 번째 타입인 string, 다음 두 번째는 튜플의 두 번째 타입인 number를 받고, 그 이후에 들어오는 값은 string과 number 중 아무거나 다 받게 됩니다.</p>
<ul>
<li>void, null, undefined</li>
</ul>
<p>함수의 반환값이 없을 때 void나 undefined를 받을 수 있습니다. 그렇다고 변수가 값이 할당되지 않을 떄를 나타내기 위하여 null은 권장하지 않습니다.<br>이러한 불안정한 연산을 막기 위해 tsconfig.json에서 <code>strictNullChecks</code> 옵션을 true로 설정해 막을 수 있습니다.</p>
<p>undefined의 경우는 초기화 되지 않았음을 의미하지만 null은 null 자체로 하나의 값이기 때문에 신중해서 사용할 필요가 있습니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/12/typescript/day1/" data-id="cjqt1b71800016lmilqo4qowb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty/day4" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/06/netty/day4/" class="article-date">
  <time datetime="2019-01-05T15:00:00.000Z" itemprop="datePublished">2019-01-06</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/06/netty/day4/">네티 알아보기 4일차 - 이벤트 핸들러</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="이벤트-루프"><a href="#이벤트-루프" class="headerlink" title="이벤트 루프"></a>이벤트 루프</h2><p>네티에서 빼놓을 수 없는 이벤트에 대해서 알아보고자 합니다.</p>
<p>통상적인 이벤트 기반 어플리케이션이 이벤트를 처리하는 방법은 크게 두 가지라고 합니다.</p>
<ul>
<li>이벤트 리스너와 이벤트 처리 스레드에 기반한 방법</li>
<li>이벤트 큐에 이벤트를 등록하고 이벤트 루프가 큐에 접근하여 사용하는 방법</li>
</ul>
<p>맨 위의 방식은 대부분의 UI처리 프레임워크가 사용하는 방법이라고 합니다. 로직을 리스너에 등록하고 처리 스레드가 등록된 로직을 수행하는 방식이죠. </p>
<p>생각나는 예를 들면<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JS : document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate);</span><br></pre></td></tr></table></figure></p>
<p>정도 있겠네요.</p>
<p>두번쨰 방식인 이벤트 루프+큐의 방식은 객체에서 이벤트가 발생하면 이벤트 큐에 입력되고 이벤트 루프 스레드가 체크해서 이벤트를 가져와 처리하는 방식입니다.<br>계속해서 체크하며 돌기 때문에 Loop인것일까요?<br>여기서 스레드가 단일과 다중으로 나뉘고 이벤트의 결과를 돌려주는 방식에 따라 콜백 패턴과 퓨처 패턴으로 나뉩니다.<br>Netty는 둘 다 지원한다고 하니 잠시 후 알아보겠습니다.</p>
<h3 id="단일-다중-스레드-이벤트-루프"><a href="#단일-다중-스레드-이벤트-루프" class="headerlink" title="단일/다중 스레드 이벤트 루프"></a>단일/다중 스레드 이벤트 루프</h3><p>단일 스레드 루프는 이벤트를 처리하는 스레드가 하나인 상태를 말합니다.<br>그래서 하나의 입력된 스레드가 이벤트 큐에 입력된 이벤트를 처리하므로 큐에 입력된 이벤트를 순차적으로 실행이 가능한 장점을 가지고 있지요.<br>단점은 당연히 기본 멀티코어인 요즘 시대에 코어를 1개밖에 못써먹는 치명적인 단점이 있습니다.<br>특히 JS기반의 Node.js… 그래서 멀티코어를 활용하고자 많은 방법을 개발 및 사용중입니다만 아무튼 그렇습니다.</p>
<p>다중 스레드 루프는 이벤트를 처리하는 스레드가 여러개인 상태를 말합니다.<br>단점은 이벤트 루프의 갯수가 한정적이므로 접근하려는 경합이 일어나며 여러 스레드가 실행하므로 실행순서와 발생순서가 일치하지 않습니다.<br>하지만 장점은 남는 자원을 아낌없이 다 쓸 수 있다는 점이지요.</p>
<p>영상하나를 올리고자 합니다. 해당 영상은 CPU vs GPU 영상 입니다만 CPU를 단일스레드, GPU를 멀티스레드라고 생각해보면 그림을 그린다는 목적을 똑같이 가졌을 때 멀티스레드로 인한 효율을 간접적으로 볼 수 있습니다.</p>
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/-P28LKWTzrI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
<blockquote>
<p>nvidia youtube에서 퍼왔습니다.</p>
</blockquote>
<p>하지만 다중 스레드 루프도 만능은 아닙니다. 스레드 경합과 컨텍스트 스위칭(스레드가 가진 스택 정보를 레지스터로 복사하는 작업)에 의한 비용이 늘어나서 코어의 활용으로 인한 성능향상보다 성능을 깎아먹게 되는 현상이 있으니 늘 적당한 갯수를 탄력적으로 모니터링하며 유지해야 하겠습니다.</p>
<h3 id="네티의-이벤트-루프"><a href="#네티의-이벤트-루프" class="headerlink" title="네티의 이벤트 루프"></a>네티의 이벤트 루프</h3><p>Netty가 다중 스레드 루프를 사용했다면 너도 나도 가져가려는 이벤트 스레드로 인해 전송하다가 채널이 닫히는 등 엄청난 혼란이 일어났겠지만 Netty의 경우 다음과 같은 특징으로 인하여 다중 스레드 루프를 사용함에도 단점을 극복했다고 합니다.</p>
<ul>
<li>네티의 이벤트는 채널에서 발생</li>
<li>이벤트 루프 객체는 큐를 가지고 있다</li>
<li>네티의 채널은 하나의 이벤트 루프에 등록된다.</li>
</ul>
<p>즉, 1채널당 1개의 이벤트 루프에만 등록되기 때문에 한곳에서만 처리가 가능하다는 것이지요.<br>그리고 루프 객체당 큐를 가지고 있기 때문에 큐를 공유하지 않아 다른 객체에서 해당 큐의 접근이 불가능하여 이벤트를 빼앗기는 일이 없다고 하겠습니다.</p>
<p>조금 비유하면 컨퍼런스를 갔는데 여러 홀에서 동시에 발표를 한다 가정하면 우리의 몸이 만화속 닌자마냥 분신술이 불가능하기 때문에 하나의 발표밖에 못듣게 되죠.<br>그래서 여러 발표(이벤트)를 함에도 홀(이벤트 큐)이 공유되지 않아 하나의 발표밖에 못듣는거죠.(이벤트 처리)</p>
<h2 id="네티의-비동기-I-O-처리"><a href="#네티의-비동기-I-O-처리" class="headerlink" title="네티의 비동기 I/O 처리"></a>네티의 비동기 I/O 처리</h2><p>앞서 살펴보았던 이벤트 처리에 비해 유용하게 쓸 수 있는 퓨처패턴을 사용해 보겠다고 합니다.(책에서)<br>퓨처패턴은 당장 완료되지는 않지만 언젠가는 완료될 것으로 생각하고 미리 짜 놓으면 퓨처 객체에서 메소드의 처리 결과에 따라 진행하는 패턴입니다.</p>
<p>간단한 코드로 표현하면 다음과 같은 것입니다.(실제로 실행은 안되니 의사코드로써 봐주시기 바랍니다.)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class NettyFuture &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Work work = new Work();</span><br><span class="line">        Future&lt;Work&gt; nettyFuture = new Future&lt;Work&gt;() &#123;</span><br><span class="line">            if (future.isDone) &#123;</span><br><span class="line">                //일이 끝났다 다음 해야할 일을...</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //끝나지 않았으니 빨리 빨리 정신으로 갈구자</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>실제로 여러분이 처음 작성한 코드에서는 퓨처패턴이 사용중이었습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f =bootstrap.bind(8888).sync();</span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>
<p>위의 채널퓨처 객체를 사용하고 있었죠. <code>sync()</code> 메소드가 bind의 결과가 올 때 까지 블로킹하고 bind의 처리가 완료되면 같이 sync메소드도 진행됩니다.<br>위의 채널이 닫힐 경우 sync로 같이 닫아주는 형식으로 진행되고 있죠. </p>
<p>즉 퓨처패턴은 일단 프로그래머는 로직을 짜면 추후에 미래의 결과에 따라 진행하는 방식입니다.</p>
<p>퓨처패턴의 진행결과를 가져와서 처리해야 하는데 while로 계속해서 가져오는 방식도 있으나 복잡성 증가라던지 조금 그래서… 이벤트 방식의 리스너에 담아서 사용도 가능합니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture.addListener(ChannelFutureListener.CLOSE) &lt;-- 이런식으로 말이죠</span><br></pre></td></tr></table></figure>
<p>다음은 해당리스너 인터페이스를 구현하면 될 것이고요.</p>
<p>일단 ChannelFutureListener 인터페이스만 살펴보면 해당 인터페이스를 통해서 제공하는 것은 다음과 같습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ChannelFutureListener.CLOSE</span><br><span class="line">ChannelFutureListener.CLOSE_ON_FAILURE</span><br><span class="line">ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE</span><br></pre></td></tr></table></figure>
<p>그 외에 여러가지 이벤트 리스너를 사용해서 비동기의 제어도 가능합니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50733800-e0488280-11d7-11e9-91fa-aa912538cef7.png" alt="ChannelFuture.addListener API"></p>
<p>보시는것과 같이 꼭 하나의 리스너만 받고 있지는 않으니 여러가지로 응용하시면 되겠습니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>네티의 이벤트 루프 스레드는 단일과 다중 스레드에서 이벤트 수행 순서의 차이가 없는 것이 장점이며 루프 스레드의 갯수를 쉽게 조정할 수 있으니 편하신대로 개발하시면 되겠습니다.<br>더 적은 고민으로 좋은 품질의 제품을 만들 수 있도록 해주었으니 잘 써먹어야겠죠.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/06/netty/day4/" data-id="cjqt1b71h00046lmimytbs88e" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty/day3" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/29/netty/day3/" class="article-date">
  <time datetime="2018-12-28T15:00:00.000Z" itemprop="datePublished">2018-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/netty/day3/">네티 알아보기 3일차 - 채널 파이프라인 + 코덱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="주요-용어들"><a href="#주요-용어들" class="headerlink" title="주요 용어들"></a>주요 용어들</h2><h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h3><ul>
<li>채널 파이프라인 - 채널에서 발생한 이벤트가 이동하는 통로</li>
<li>이벤트 핸들러 - 채널 파이프라인을 따라 이동한 이벤트를 처리하는 클래스</li>
<li>코덱 - 이벤트 핸들러를 상속받아서 구현한 것</li>
</ul>
<h2 id="네티의-이벤트-실행"><a href="#네티의-이벤트-실행" class="headerlink" title="네티의 이벤트 실행"></a>네티의 이벤트 실행</h2><p>보통의 연결된 소켓에서 데이터를 받는다면 다음과 같은 로직으로 처리할 것입니다.</p>
<ol>
<li>소켓에 데이터가 있는지 확인</li>
<li>데이터가 있으면 읽는 메서드를 호출 후 데이터 처리</li>
<li>데이터가 올 때 까지 기달리다가 오면 2번으로 돌아감</li>
<li>네트워크가 종료되면 관련된 부분 처리</li>
</ol>
<p>Netty에서는 다음과 같이 처리합니다.</p>
<ol>
<li>데이터가 들어오면 Netty의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.</li>
<li>이벤트 핸들러에 데이터 수신 후 작동할 이벤트가 있는지 확인ㅁ</li>
<li>가져온 이벤트 핸들러에 관련 메소드가 없으면 이벤트가 처리되거나 핸들러를 다 가져올떄까지 계속 반복</li>
<li>네트워크가 종료되면 관련된 부분 처리</li>
</ol>
<p>즉, 데이터를 입출력 후 처리하는 부분은 이벤트로 관리하고 있으니 이벤트 처리만 해주면 Netty를 쉽게 쓸 수 있습니다.</p>
<h2 id="채널-파이프라인"><a href="#채널-파이프라인" class="headerlink" title="채널 파이프라인"></a>채널 파이프라인</h2><h3 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h3><p><img src="https://user-images.githubusercontent.com/20100284/50535726-5887c600-0b90-11e9-9a1a-b81707c78ce5.png" alt="netty.io API의 설명"></p>
<p>저렇게 채널에서 이벤트를 받으면 파이프라인으로 들어가서 이벤트 핸들러에 의해 맞는 이벤트를 처리하게 됩니다.<br>하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있습니다.</p>
<p>다시 에코서버안의 내용을 가져와서 보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(loopGroup, workerGroup)</span><br><span class="line">         .channel(NioServerSocketChannel.class)</span><br><span class="line">         .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">           protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">             ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">             pipeline.addLast(new EchoServerHandler());</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>
<p>해당 코드를 보면 <code>ChannelPipeline pipeline = socketChannel.pipeline()</code>에서 파라미터로 받은 채널안의 파이프라인을 가져오고 다음 <code>pipeline.addLast(new EchoServerHandler())</code> 메소드로 파이프라인의 마지막에 핸들러를 등록하는 것을 볼 수 있습니다.</p>
<p>그리고 Netty는 소켓채널에 파이프라인을 등록하고 핸들러의 설정을 등록하기 위해서 세 단계 프로세스를 거칩니다.</p>
<ol>
<li>클라이언트 연결에 대응하는 채널 객체를 생성하고 빈 채널 파이프라인 객체를 생성하여 소켓 채널에 할당합니다.</li>
<li>채널에 등록된 <code>ChannelInitializer</code> 인터페이스의 구현체를 가져와서 <code>initChannel</code> 메소드를 호출합니다.</li>
<li>1에서 등록된 파이프라인 객체를 가져온 후 파이프라인에 입력된 이벤트 핸들러 객체를 등록합니다.</li>
</ol>
<p>위의 세 단계가 완료 되면 채널이 등록됐다는 이벤트와 함께 데이터 송수신을 위한 이벤트 처리가 시작된다.</p>
<h2 id="이벤트-핸들러"><a href="#이벤트-핸들러" class="headerlink" title="이벤트 핸들러"></a>이벤트 핸들러</h2><p>Netty는 비동기 처리를 위해 두가지를 제공합니다. 하나는 퓨처패턴이며 하나는 이벤트 핸들러입니다.<br>여기서는 이벤트 핸들러에 대해 자세히 알아보겠습니다.</p>
<p>대부분의 이벤트는 한 번만 수행하지만 다시 이벤트를 발생시켜 다른 등록된 핸들러에서 추가로 이벤트 처리를 시킬 수 있습니다.</p>
<h3 id="채널-인바운드-이벤트"><a href="#채널-인바운드-이벤트" class="headerlink" title="채널 인바운드 이벤트"></a>채널 인바운드 이벤트</h3><p>인바운드 이벤트는 소켓 채널에서 발생한 이벤트 중 상대방이 어떤 동작을 취했을 때 발생합니다.<br>클라이언트가 서버에 접속한 상태에서 서버에게 데이터를 보낼 경우 Netty의 소켓 채널은 데이터를 받았다고 채널 파이프라인에게 데이터 수신 이벤트를 보내고 채널 파이프라인은 등록한 인바운드 이벤트 핸들러를 호출합니다.</p>
<p><code>ChannelInboundHandler</code>인터페이스를 가지고 인바운드 이벤트를 처리할 수 있습니다.<br>안의 메소드는 다음과 같습니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50545348-05774700-0c54-11e9-8014-9de540244325.png" alt="Inbound"></p>
<p>이벤트 호출 순서는 다음과 같습니다. 위에서 아래 순입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">이벤트 루프에 채널 등록(channelRegistered)</span><br><span class="line"></span><br><span class="line">채널 활성화(channelActive)</span><br><span class="line"></span><br><span class="line">데이터 수신(channelRead)</span><br><span class="line"></span><br><span class="line">데이터 수신 완료(channelReadComplete)</span><br><span class="line"></span><br><span class="line">채널 비활성화(channelInactive)</span><br><span class="line"></span><br><span class="line">이벤트 루프에서 채널 제거(channelUnregistered)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>아마 대부분 메인로직은 데이터 수신~수신완료에 쓰일것이라 보입니다.</p>
</blockquote>
<p>이벤트를 간단히 정리해보겠습니다.</p>
<ul>
<li><code>channelRegistered</code>의 이벤트 발생 시점은 서버와 클라이언트 모두 처음 소켓 채널이 생성할 때 발생하며, 서버의 경우 클라이언트 소켓 채널이 서버 소켓 채널에 등록될 때 다시 발생합니다.</li>
<li><code>channelActive</code>의 이벤트는 서버 또는 클라이언트가 연결한 직후 한 번 수행할 작업을 처리하기에 적합합니다.(예를 들면 Hello Client 라던가…)</li>
<li><code>channelRead</code>와 <code>channelReadComplete</code> 이벤트는 데이터의 수신시 발생하지만 Read는 채널에 데이터가 있을 때 발생하고 Complete는 데이터를 다 읽었을 때 발생합니다.</li>
<li><code>channelInactive</code>가 발생하면 Read가 불가능합니다.</li>
<li><code>channelUnregistered</code>가 발생하면 등록했던 소켓에 대한 이벤트 처리가 불가능합니다.</li>
</ul>
<h3 id="채널-아웃바운드-이벤트"><a href="#채널-아웃바운드-이벤트" class="headerlink" title="채널 아웃바운드 이벤트"></a>채널 아웃바운드 이벤트</h3><p>대부분 클라이언트 객체에서 처리할 것으로 보이는 아웃바운드입니다.<br>요청을 보내거나 데이터 전송, 소켓 닫기 등의 이벤트를 가지고 있습니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50545453-6ce2c600-0c57-11e9-8942-ee94220bf243.png" alt="Outbound"></p>
<p>이벤트를 간단히 정리해보겠습니다.</p>
<ul>
<li><code>bind</code> 이벤트는 서버 소켓 채널에 클라이언트가 연결을 대기하는 IP와 포트가 설정되었을 때 발생합니다. 파라미터 중 <code>SocketAddress</code>로 서버에서 사용하는 IP/포트 정보를 확인 가능합니다.</li>
<li><code>connect</code> 이벤트는 서버에 연결되었을 때 발생합니다. </li>
<li><code>disconnect</code> 이벤트는 연결이 끊어졌을 때 발생합니다.</li>
<li><code>close</code> 이벤트는 소켓 채널의 연결이 닫혔을 때 발생합니다.</li>
<li><code>write</code> 이벤트는 소켓 채널에 데이터가 기록되면 발생합니다.</li>
<li><code>flush</code> 이벤트는 소켓 채널에 대한 flush 메소드가 호출되면 발생한다고 합니다.</li>
</ul>
<h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>대부분의 이벤트가 <code>ChannelHandlerContext</code>를 파라미터로 제공하는 것을 볼 수 있습니다. 이 녀석의 경우 채널 파이프라인이나 다른 핸들러의 상호작용을 도와주는 인터페이스입니다.<br>즉, <code>writeAndFlush</code>등의 메서드로 채널에 데이터를 기록하며 <code>close</code> 메소드로 연결종료나 자신이 속한 파이프라인의 동적 수정, 다음 Handler에 통지하는 등 다양한 기능을 수행합니다.</p>
<h2 id="코덱"><a href="#코덱" class="headerlink" title="코덱"></a>코덱</h2><p>우리가 동영상 플레이어를 설치 시 말하는 그 코덱과 의미가 같습니다. 즉, 전송을 보내는/받은 파일을 특정 루틴에 의해 압축,변환 시키고 해제를 시키는 라이브러리 같은 개념으로 생각하면 되겠죠.<br>Netty 에서는 코덱을 통해 데이터-패킷으로 상호 변환을 합니다. 그리고 Netty의 코덱은 템플릿 메소드 패턴을 사용했다고 합니다.(실행순서만 위에서 설정하고 실제 구현은 하위에서)</p>
<p>사용자가 직접 만들 수 있지만 대부분의 프로토콜은 Netty에서 기본제공하므로 가져다가 쓰시는 것을 추천합니다.<br>기본 예제는 io.netty.example 패키지에 포함되어있다고 합니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이벤트가 참 많네요. 코덱까지 세트로 제공하니 쉽게 데이터를 주고 받을 수 있을 것 같은 느낌입니다.<br>3일차를 마치고 4일차로 가보겠습니다. 점점 양이 많아지는것을 느낍니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/29/netty/day3/" data-id="cjqt1b71k00076lmixuvm7cfy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty/day2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/25/netty/day2/" class="article-date">
  <time datetime="2018-12-24T15:00:00.000Z" itemprop="datePublished">2018-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/25/netty/day2/">네티 알아보기 2일차 - 부트스트랩</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2일차를 신나게 달려봅시다.</p>
<h1 id="3장"><a href="#3장" class="headerlink" title="3장"></a>3장</h1><h2 id="프로토콜"><a href="#프로토콜" class="headerlink" title="프로토콜"></a>프로토콜</h2><p>아무래도 통신관련 프레임워크기 때문에 통신 프로토콜을 모를 수도 없어서 간단하게 알아보도록 하겠습니다.</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP의 경우 연결을 확인하고 메시지를 전송하는 것을 보장하는 특성을 가지고 있습니다.<br>메시지를 받을때마다 받았다는 신호를 보내 서로 전송되었고 받았는지 확인하죠.</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP는 메시지는 전송하지만 받았는지 전혀 확인하지 않기 때문에 누락, 분실, 메시지 순서를 보장하지 않는 등의 특징을 가지고 있습니다.<br>그럼에도 왜 쓰냐하면 체크하는 과정이 없기 때문에 TCP에 비해 상대적으로 오버헤드가 적고 속도가 빠른 장점이 있습니다.</p>
<h3 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h3><p>검색하다가 IBM에서 좋은 정보를 제공하기에 가져왔습니다.</p>
<p>스트림 전송 제어 프로토콜(SCTP)은 TCP와 유사한 연결 지향 프로토콜이지만 UDP와 유사한 메시지 지향 데이터 전송을 제공합니다.<br>일반적으로 SCTP는 안정적이면서도 메시지 지향적인 데이터 전송을 필요로 하는 VoIP(Voice over IP)와 같은 특정 애플리케이션에 대해 더 많은 유연성을 제공합니다. 이런 애플리케이션 범주에 대해 SCTP는 대부분 TCP나 UDP보다 더 적합합니다.</p>
<ul>
<li>TCP는 신뢰 가능하며 엄격한 전송 순서의 데이터 전달을 제공합니다. 신뢰성이 필요로 하지만 순서화되지 않았거나 부분적으로만 순서화된 데이터 전달을 허용하는 애플리케이션의 경우, TCP는 HOL(head-of-line) 블로킹으로 인해 불필요한 지연을 초래할 수 있습니다. 단일 연결 내에 여러 스트림 개념을 사용하는 SCTP는 데이터를 다른 스트림으로부터 논리적으로 분리하는 동시에 하나의 스트림 내에서 엄격한 순서로 전달할 수 있습니다.</li>
<li>SCTP는 바이트 지향인 TCP와는 달리 메시지 지향입니다. TCP의 바이트 지향 특성으로 인해 애플리케이션은 메시지 경계를 유지하려면 고유한 레코드 표시를 추가해야 합니다.</li>
<li>SCTP는 멀티-홈 기능을 사용하여 어느 정도의 결함 허용치를 제공합니다. 호스트는 동일하거나 다른 네트워크에서 둘 이상의 네트워크 인터페이스가 접속된 경우 멀티-홈으로 간주됩니다. 두 개의 멀티-홈 호스트 사이에 SCTP 연관을 설정할 수 있습니다. 이 경우 두 엔드포인트의 모든 IP 주소가 연관 시작 시에 교환됩니다. 이를 통해 각 엔드포인트는 인터페이스 중 하나가 어떤 이유에서이건 작동 중지된 경우 대체 인터페이스를 통해 피어에 연결 가능한 한 남은 연결 기간 동안 이러한 주소를 사용할 수 있습니다.</li>
<li>SCTP는 TCP 및 UDP는 제공하지 않는 추가 보안 기능을 제공합니다. SCTP에서 연결 설정 시 자원 할당은 쿠키 교환 메커니즘을 사용하여 클라이언트의 ID를 검증하기 전까지 지연되어 서비스 거부 공격 가능성을 줄입니다.</li>
</ul>
<h3 id="프로토콜간-차이점"><a href="#프로토콜간-차이점" class="headerlink" title="프로토콜간 차이점"></a>프로토콜간 차이점</h3><p>표 하나로 설명합니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50411940-77f8b900-0847-11e9-89af-4f0dc106a21b.png" alt="차이점(어디서 가져온지 기억이 잘..)"></p>
<h2 id="부트스트랩이란"><a href="#부트스트랩이란" class="headerlink" title="부트스트랩이란?"></a>부트스트랩이란?</h2><p>제가 아는 웹 프론트엔드 프레임워크가 아니라 Netty에서 가장 처음 수행되는 부분으로써 동작과 설정을 지정하여 가장 기본이 되는 부분이라 합니다.<br>API Doc의 Bootstrap 클래스에서는 다음과 같이 얘기하고 있습니다.</p>
<blockquote>
<p>부트스트랩은 채널을 쉽게 사용할 수 있도록 해주는 것</p>
</blockquote>
<h3 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h3><p>논리적 구조는 다음과 같습니다.</p>
<ul>
<li>소켓 모드 및 I/O종류</li>
<li>이벤트 루프</li>
<li>채널 파이프라인 설정</li>
<li>소켓 주소 및 포트 등의 옵션 설정</li>
</ul>
<p>빌더 패턴을 사용하여 선택적인 옵션을 파악하기 쉽도록 추가할 수 있습니다.</p>
<h3 id="시작해보기"><a href="#시작해보기" class="headerlink" title="시작해보기"></a>시작해보기</h3><p>가장 처음에 작성했던 에코 서버 코드를 가져와서 조금 수정 후 확인해봅시다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup loopGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">bootstrap.group(loopGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(new EchoServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">ChannelFuture f =bootstrap.bind(8888).sync();</span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>
<p>먼저 <code>new NioEventLoopGroup()</code>를 보면 생성자의 인수가 없는데 이럴 경우 사용할 스레드 수를 하드웨어의 스레드 수로 한다고 합니다.<br>스레드 수는 하드웨어가 가지고 있는 CPU 코어 수의 2배를 사용한다 합니다. 4C 8T의 경우 하드웨어(CPU)에서 지원하는 8T의 두 배인 16개죠. 그리고 loopGroup 변수는 사용할 스레드 수를 1개로 지정하였습니다.<br><code>ServerBootstrap.group()</code> 메소드는 NioEventLoopGroup을 인수로 받는데 첫번째는 연결에 사용할 스레드이고 두 번째 인수는 연결된 소켓에 대한 I/O처리를 담당합니다.<br>저는 연결은 한번만 하고 끝나니 하나만 사용했고, I/O의 경우 어떻게 몇개가 들어올지 모르니 여러개의 스레드를 사용했다고 생각했습니다.<br><code>.channel()</code> 메소드는 API명세에 따르면 Channel 인터페이스를 구현한 객체나 채널팩토리를 사용할 수 있고 이 예제에서는 NioServerSocketChannel 클래스를 설정했기 때문에 Nio모드를 사용합니다.<br><code>.childHandler</code> 메소드는 API에 채널에서 요청이 왔을 때 제공할 ChannelHandler를 설정합니다.</p>
<p>연결 방법을 바꾸고 싶으면 <code>.channel()</code> 부분에서 제공하는 클래스를 변경하면 입출력 모드를 쉽게 바꿀 수 있도록 Netty에서는 제공하고 있습니다.<br>지원하는 클래스는 다음과 같습니다.(안보이면 클릭하셔서 보시기 바랍니다)</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50411468-8ba22080-0843-11e9-920e-54fe248d67a7.png" alt="지원클래스 with Netty"></p>
<p>이 중 Epoll은 *nix에서 동작한다고 합니다.</p>
<h3 id="부트스트랩-내-간단한-API-소개"><a href="#부트스트랩-내-간단한-API-소개" class="headerlink" title="부트스트랩 내 간단한 API 소개"></a>부트스트랩 내 간단한 API 소개</h3><p>channelFactory - 소켓 입출력 모드 설정</p>
<p>channel 메소드와 동일한 기능을 수행합니다.</p>
<p>handler - 이벤트 핸들러 설정</p>
<p>소켓 채널에서 발생한 이벤트를 수신하여 처리합니다.</p>
<p>childHandler - 소켓 채널의 데이터 가공 핸들러 설정</p>
<p>소켓 채널로 송수신 되는 데이터를 가공하는 핸들러입니다. ChannelHandler 인터페이스를 구현한 클래스를 인수로 입력 가능합니다.</p>
<p>option - 소켓의 옵션을 설정합니다.</p>
<p>소켓의 옵션이란 소켓의 동작 방식을 지정하는 것을 말합니다.<br>소켓 옵션은 어플리케이션의 값을 바꾸는 것이 아니라 커널에서 사용되는 값을 변경한다는 의미입니다.</p>
<p>childOption - 소켓의 옵션을 설정합니다.</p>
<p>option 메소드는 서버의 옵션을, childOption 메소드는 클라이언트의 옵션을 설정합니다.</p>
<p>group - 이벤트 루프 설정</p>
<p>소켓 채널의 이벤트 처리를 위한 루프 객체를 생성합니다.<br>클라이언트는 단 하나의 이벤트 루프만 설정할 수 있습니다.</p>
<p>channel - 입출력모드 설정</p>
<p>서버 - 클라이언트의 입출력 채널을 설정합니다.<br>서버와 클라이언트는 설정할 수 있는 입출력 모드가 상이합니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>부트스트랩으로 서버와 클라이언트에서 각자 연결하고 처리할 수 있는 방법을 쉽게 제공합니다.<br>여러가지 준비해 놓았으니 상황에 맞춰 가장 최적의 연결방법을 찾아서 해야 겠지요…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/25/netty/day2/" data-id="cjqt1b71i00056lmidc0ud5tf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty/day1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/24/netty/day1/" class="article-date">
  <time datetime="2018-12-24T07:00:00.000Z" itemprop="datePublished">2018-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/24/netty/day1/">네티 알아보기 1일차 - 기본 환경설정</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>그동안 사놓고 안읽어봤던 자바 네트워크 소녀 Netty를 익히면서 쓰는 글입니다.<br>github blog + hexo로 만들어보는 첫번쨰 블로그이기도 하죠</p>
<h1 id="1장"><a href="#1장" class="headerlink" title="1장"></a>1장</h1><h2 id="네티란"><a href="#네티란" class="headerlink" title="네티란?"></a>네티란?</h2><p><code>Netty는 유지 보수 가능한 높은 성능 프로토콜 서버 &amp; 클라이언트를 빠르게 개발할 수 있는 비동기적인 이벤트 기반 네트워크 어플리케이션 프레임워크</code>라고 합니다.</p>
<h2 id="시작해보기"><a href="#시작해보기" class="headerlink" title="시작해보기"></a>시작해보기</h2><p>1탄으로 Java 1.8 + maven 환경에서 작업해 보겠습니다. (추후에 생각나면 스프링도…)</p>
<p>라이브러리를 다운받아서 직접 lib 폴더에 넣으셔도 되지만 저는 그냥 maven으로 하겠습니다.</p>
<p>가장 먼저 프로젝트를 만들고 pom.xml에 netty 레포지토리 태그를 집어넣습니다.</p>
<p>개발환경은 5.0 alpha가 있지만 4.1 final버전으로 하겠습니다.</p>
<p>pom.xml에 다음과 같이 넣어주세요.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.32.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>그리고 maven install을 하셔서 lib에 netty.jar가 정상적으로 들어있는지 확인해주세요.</p>
<p>intellij IDEA를 예로 들어서 정상적으로 라이브러리가 들어왔는지 확인 하려면 External Libraries에 들어있는지 확인하시면 되겠습니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50393342-fd716000-0798-11e9-9b1d-3aa65d041566.png" alt="라이브러리 확인"></p>
<p>그럼 이제 Netty 프레임워크로 책내용을 따라서 만들어보겠습니다.</p>
<h2 id="에코서버-만들기"><a href="#에코서버-만들기" class="headerlink" title="에코서버 만들기"></a>에코서버 만들기</h2><h3 id="일단-무조건-따라쳐봅시다"><a href="#일단-무조건-따라쳐봅시다" class="headerlink" title="일단 무조건 따라쳐봅시다."></a>일단 무조건 따라쳐봅시다.</h3><p>서버를 만들어 봅시다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class EchoServer &#123;</span><br><span class="line"></span><br><span class="line">    public void echo() throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup loopGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">            bootstrap.group(loopGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(new EchoServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f =bootstrap.bind(8888).sync();</span><br><span class="line"></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>따라치다보면 같은 클래스 명을 가진 라이브러리를 만날 수도 있습니다만…(안만날수도있고요) 무조건 io.netty.이하로 선택합니다.</p>
<p>살펴보니 EventLoopGroup이라는 것을 만들어서 ServerBootStrap이라는 것에 집어넣습니다.<br>채널에 클래스를 뭔가 하나 담고 밑에서 일할 핸들러를 하나 만들고 파이프라인이라는 것을 만들어서 마지막에 핸들러를 하나 담았습니다.<br>그리고 8888 포트를 만들어서 sync메소드로 동기화같은 작업을 하나 봅니다.</p>
<p>당연히 실행은 new EchoServer.echo()로 하겠지요.</p>
<p>이번에는 파이프 라인에 들어갈 핸들러를 만들어 보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        String readMsg = ((ByteBuf)msg).toString(Charset.defaultCharset());</span><br><span class="line">        System.out.println(&quot;수신한 문자열 [&quot;+readMsg + &quot;]&quot;);</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이벤트 기반의 프레임워크라고 소개했듯이 핸들러를 통해 이벤트에 맞춰 어떻게 작업할 것인지 선택합니다.<br>여기서는 ChannelInboundHandlerAdapter를 상속받아서 이벤트 콜백을 설정합니다.<br>channelRead와 모두 완료됐을때 호출될 channelReadComplete를 오버라이드 해서 완료했을때의 이벤트를 설정합니다.</p>
<p>그 다음 자바를 실행하고 telnet으로 접속해서 날려보면 자바 콘솔창에 확인이 가능합니다.</p>
<blockquote>
<p>한글자씩 안찍히고 엔터키를 입력시 입력한 문자가 그대로 텔넷 클라이언트에 한번 더 찍힌다면 연결 종류가 Raw라서 그렇다고 한다. 리눅스 쓰는데 해당 증상이 나타나버렸습니다…</p>
</blockquote>
<h2 id="에코-클라이언트-만들기"><a href="#에코-클라이언트-만들기" class="headerlink" title="에코 클라이언트 만들기"></a>에코 클라이언트 만들기</h2><h3 id="같이-만들어-봅시다"><a href="#같이-만들어-봅시다" class="headerlink" title="같이 만들어 봅시다."></a>같이 만들어 봅시다.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class EchoClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ByteBuf msgBuffer = Unpooled.buffer();</span><br><span class="line">        byte[] sendMsgByte = &quot;반가워요&quot;.getBytes();</span><br><span class="line">        msgBuffer.writeBytes(sendMsgByte);</span><br><span class="line">        ctx.writeAndFlush(msgBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        String readMsg = ((ByteBuf)msg).toString(Charset.defaultCharset());</span><br><span class="line">        System.out.println(&quot;수신한 문자열 [&quot;+readMsg + &quot;]&quot;);</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>책에 나온 차이점이라면 처음에 채널이 연결되었을때 이벤트를 추가해준것 밖에 없습니다.<br>실행해봅시다.</p>
<h1 id="2장"><a href="#2장" class="headerlink" title="2장"></a>2장</h1><h2 id="인바운드-아웃바운드"><a href="#인바운드-아웃바운드" class="headerlink" title="인바운드, 아웃바운드"></a>인바운드, 아웃바운드</h2><h3 id="인바운드란"><a href="#인바운드란" class="headerlink" title="인바운드란?"></a>인바운드란?</h3><p>당사자 입장에서 들어오는 것</p>
<h3 id="아웃바운드란"><a href="#아웃바운드란" class="headerlink" title="아웃바운드란?"></a>아웃바운드란?</h3><p>당사자 입장에서 나가는 것</p>
<h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><p>내가 친구에게 <code>안녕</code>이라는 메시지를 보냈다면, 친구입장에서는 <code>안녕</code>이라는 메시지가 인바운드 된 것이고 나에게는 <code>안녕</code>메시지가 아웃바운드 된 것이다.</p>
<h2 id="동기-비동기"><a href="#동기-비동기" class="headerlink" title="동기, 비동기"></a>동기, 비동기</h2><p>이 것은 굳이 Netty가 아니더라도 수 많은 곳에서 사용합니다. 사전에 정의된 해설은 다음과 같습니다.</p>
<h3 id="동기"><a href="#동기" class="headerlink" title="동기"></a>동기</h3><p>데이터 전송에 있어서 일정 클록 신호에 맞추어 데이터의 송수신을 하는 방법으로 통신을 시작할 때, 데이터의 최초에 통신 속도와 통신 방법을 식별하기 위한 동기 캐릭터(synchronous character)를 첨부하여 송신하는 방법</p>
<h3 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h3><p>통신을 하는 양쪽 장치가 데이터를 주고받을 때 일정한 속도를 유지하는 것이 아니라, 약정된 신호에 기준하여 동기를 맞추는 통신 방법</p>
<h2 id="블로킹-논블로킹"><a href="#블로킹-논블로킹" class="headerlink" title="블로킹, 논블로킹"></a>블로킹, 논블로킹</h2><p>소켓통신에 주로 쓰이는 용어입니다. 물론 다른곳에도 쓰일수도 있지요.</p>
<h3 id="블로킹"><a href="#블로킹" class="headerlink" title="블로킹"></a>블로킹</h3><p>요청한 작업이 완료되거나 에러가 발생해서 끝날 때 까지 응답을 돌려주지 않는 방법</p>
<h3 id="논-블로킹"><a href="#논-블로킹" class="headerlink" title="논 블로킹"></a>논 블로킹</h3><p>작업 완료 여부와 상관없이 결과를 돌려주는 방법</p>
<p>블로킹의 경우 관공서 민원실이나 은행 업무처리정도로 생각하면 쉬울 것 같고 논 블로킹의 경우 공항이나 티켓교환소의 인포메이션 센터 정도로 생각하면 되지 않을까 싶습니다.<br>은행이나 관공서의 경우 1:1로 고객의 모든 일이 끝날때 까지 붙어서 처리하고 인포메이션 센터는 나에게 정보를 알려주고 내가 이해하는 동안 다른사람이 물어보면 바로 그 사람에게 응답을 해주고 내가 다시 질문 할 경우 알려주는 등 동시에 여러가지 여러명에게 업무를 한다고 생각하면 쉬울 것 같습니다.</p>
<h2 id="이벤트기반-프로그래밍"><a href="#이벤트기반-프로그래밍" class="headerlink" title="이벤트기반 프로그래밍"></a>이벤트기반 프로그래밍</h2><p>내가 설정한 이벤트가 발생하면 이벤트에 직접 등록한 루틴이 실행되는 방식입니다.<br>즉, 이벤트 발생 -&gt; 이벤트를 받아서 처리할 것이 있는지 검색 -&gt; 실행 순이겠죠.</p>
<p>Netty에서는 ChannelInboundHandlerAdapter로 여러 이벤트 기반 프로그래밍을 지원합니다.<br>여기서 채널은 소켓 채널입니다.</p>
<h2 id="Future-java"><a href="#Future-java" class="headerlink" title="Future(java)"></a>Future(java)</h2><p>간단하게 알아보면 어떠한 로직을 처리했을때 처리한 값을 받아 작업하는 방식입니다. 비동기에서 쓰이며 결과값을 얻을 때 까지 필요에 의해 블록처리가 될 수 있습니다.<br>작업이 정상적으로 완료/취소 되었는지 확인을 위해 방법을 제공하며 성공적으로 수행시 <code>get</code> 취소했을경우 <code>cancel</code> 메소드로 수행됩니다.(인터페이스 기준)</p>
<p>여기서 1일차를 마치겠습니다. 2일차에서 만나요.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/24/netty/day1/" data-id="cjqt1b71100006lmix8jbeyqt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-about/about" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/23/about/about/" class="article-date">
  <time datetime="2018-12-23T08:00:51.000Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/About/">About</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/23/about/about/">about</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="나는-누구인가요"><a href="#나는-누구인가요" class="headerlink" title="나는 누구인가요?"></a>나는 누구인가요?</h2><p>쓸데없이 나이만 먹은 남자입니다. 취미는 게임과 컴퓨터 하드웨어 정보수집이예요.</p>
<h3 id="간단한-프로필"><a href="#간단한-프로필" class="headerlink" title="간단한 프로필"></a>간단한 프로필</h3><p>출생 : 1990년생</p>
<h3 id="일하면서-해봤던-것"><a href="#일하면서-해봤던-것" class="headerlink" title="일하면서 해봤던 것"></a>일하면서 해봤던 것</h3><p>frontend : HTML, CSS(with LESS), Javascript(with jQuery)<br>backend : JAVA(Spring), Classic ASP, ASP.NET &amp; PHP(문자메시지 모듈만 연동해본 수준)<br>Database : oracle, mysql<br>Server : Apache-Tomcat, IIS, AWS(EC2, S3)</p>
<p>##스터디에서 해봤던 것<br>Javascript(~ES6), Node.JS</p>
<h3 id="경력사항"><a href="#경력사항" class="headerlink" title="경력사항"></a>경력사항</h3><ol>
<li>SI회사(2015.11 ~ 2018.02)</li>
<li>인테리어 관련 쇼핑몰(2018.07 ~ 2018.11)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/23/about/about/" data-id="cjqt1b71f00036lmi81cp12vx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/About/">About</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/TypeScript/">TypeScript</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">1월 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">12월 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/12/typescript/day1/">타입스크립트 1</a>
          </li>
        
          <li>
            <a href="/2019/01/06/netty/day4/">네티 알아보기 4일차 - 이벤트 핸들러</a>
          </li>
        
          <li>
            <a href="/2018/12/29/netty/day3/">네티 알아보기 3일차 - 채널 파이프라인 + 코덱</a>
          </li>
        
          <li>
            <a href="/2018/12/25/netty/day2/">네티 알아보기 2일차 - 부트스트랩</a>
          </li>
        
          <li>
            <a href="/2018/12/24/netty/day1/">네티 알아보기 1일차 - 기본 환경설정</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 halim j<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>
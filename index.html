<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>잊을것 같으면 블로그</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="잊을것 같으면 블로그">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="잊을것 같으면 블로그">
<meta property="og:locale" content="ko-kr">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="잊을것 같으면 블로그">
  
    <link rel="alternate" href="/atom.xml" title="잊을것 같으면 블로그" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">잊을것 같으면 블로그</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-netty/day3" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/29/netty/day3/" class="article-date">
  <time datetime="2018-12-28T15:00:00.000Z" itemprop="datePublished">2018-12-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/29/netty/day3/">네티 알아보기 3일차 - 채널 파이프라인 + 코덱</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="주요-용어들"><a href="#주요-용어들" class="headerlink" title="주요 용어들"></a>주요 용어들</h2><h3 id="정의"><a href="#정의" class="headerlink" title="정의"></a>정의</h3><ul>
<li>채널 파이프라인 - 채널에서 발생한 이벤트가 이동하는 통로</li>
<li>이벤트 핸들러 - 채널 파이프라인을 따라 이동한 이벤트를 처리하는 클래스</li>
<li>코덱 - 이벤트 핸들러를 상속받아서 구현한 것</li>
</ul>
<h2 id="네티의-이벤트-실행"><a href="#네티의-이벤트-실행" class="headerlink" title="네티의 이벤트 실행"></a>네티의 이벤트 실행</h2><p>보통의 연결된 소켓에서 데이터를 받는다면 다음과 같은 로직으로 처리할 것입니다.</p>
<ol>
<li>소켓에 데이터가 있는지 확인</li>
<li>데이터가 있으면 읽는 메서드를 호출 후 데이터 처리</li>
<li>데이터가 올 때 까지 기달리다가 오면 2번으로 돌아감</li>
<li>네트워크가 종료되면 관련된 부분 처리</li>
</ol>
<p>Netty에서는 다음과 같이 처리합니다.</p>
<ol>
<li>데이터가 들어오면 Netty의 이벤트 루프가 채널 파이프라인에 등록된 첫 번째 이벤트 핸들러를 가져온다.</li>
<li>이벤트 핸들러에 데이터 수신 후 작동할 이벤트가 있는지 확인ㅁ</li>
<li>가져온 이벤트 핸들러에 관련 메소드가 없으면 이벤트가 처리되거나 핸들러를 다 가져올떄까지 계속 반복</li>
<li>네트워크가 종료되면 관련된 부분 처리</li>
</ol>
<p>즉, 데이터를 입출력 후 처리하는 부분은 이벤트로 관리하고 있으니 이벤트 처리만 해주면 Netty를 쉽게 쓸 수 있습니다.</p>
<h2 id="채널-파이프라인"><a href="#채널-파이프라인" class="headerlink" title="채널 파이프라인"></a>채널 파이프라인</h2><h3 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h3><p><img src="https://user-images.githubusercontent.com/20100284/50535726-5887c600-0b90-11e9-9a1a-b81707c78ce5.png" alt="netty.io API의 설명"></p>
<p>저렇게 채널에서 이벤트를 받으면 파이프라인으로 들어가서 이벤트 핸들러에 의해 맞는 이벤트를 처리하게 됩니다.<br>하나의 채널 파이프라인에 여러 이벤트 핸들러를 등록할 수 있습니다.</p>
<p>다시 에코서버안의 내용을 가져와서 보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bootstrap.group(loopGroup, workerGroup)</span><br><span class="line">         .channel(NioServerSocketChannel.class)</span><br><span class="line">         .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">           protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">             ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">             pipeline.addLast(new EchoServerHandler());</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure>
<p>해당 코드를 보면 <code>ChannelPipeline pipeline = socketChannel.pipeline()</code>에서 파라미터로 받은 채널안의 파이프라인을 가져오고 다음 <code>pipeline.addLast(new EchoServerHandler())</code> 메소드로 파이프라인의 마지막에 핸들러를 등록하는 것을 볼 수 있습니다.</p>
<p>그리고 Netty는 소켓채널에 파이프라인을 등록하고 핸들러의 설정을 등록하기 위해서 세 단계 프로세스를 거칩니다.</p>
<ol>
<li>클라이언트 연결에 대응하는 채널 객체를 생성하고 빈 채널 파이프라인 객체를 생성하여 소켓 채널에 할당합니다.</li>
<li>채널에 등록된 <code>ChannelInitializer</code> 인터페이스의 구현체를 가져와서 <code>initChannel</code> 메소드를 호출합니다.</li>
<li>1에서 등록된 파이프라인 객체를 가져온 후 파이프라인에 입력된 이벤트 핸들러 객체를 등록합니다.</li>
</ol>
<p>위의 세 단계가 완료 되면 채널이 등록됐다는 이벤트와 함께 데이터 송수신을 위한 이벤트 처리가 시작된다.</p>
<h2 id="이벤트-핸들러"><a href="#이벤트-핸들러" class="headerlink" title="이벤트 핸들러"></a>이벤트 핸들러</h2><p>Netty는 비동기 처리를 위해 두가지를 제공합니다. 하나는 퓨처패턴이며 하나는 이벤트 핸들러입니다.<br>여기서는 이벤트 핸들러에 대해 자세히 알아보겠습니다.</p>
<p>대부분의 이벤트는 한 번만 수행하지만 다시 이벤트를 발생시켜 다른 등록된 핸들러에서 추가로 이벤트 처리를 시킬 수 있습니다.</p>
<h3 id="채널-인바운드-이벤트"><a href="#채널-인바운드-이벤트" class="headerlink" title="채널 인바운드 이벤트"></a>채널 인바운드 이벤트</h3><p>인바운드 이벤트는 소켓 채널에서 발생한 이벤트 중 상대방이 어떤 동작을 취했을 때 발생합니다.<br>클라이언트가 서버에 접속한 상태에서 서버에게 데이터를 보낼 경우 Netty의 소켓 채널은 데이터를 받았다고 채널 파이프라인에게 데이터 수신 이벤트를 보내고 채널 파이프라인은 등록한 인바운드 이벤트 핸들러를 호출합니다.</p>
<p><code>ChannelInboundHandler</code>인터페이스를 가지고 인바운드 이벤트를 처리할 수 있습니다.<br>안의 메소드는 다음과 같습니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50545348-05774700-0c54-11e9-8014-9de540244325.png" alt="Inbound"></p>
<p>이벤트 호출 순서는 다음과 같습니다. 위에서 아래 순입니다.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">이벤트 루프에 채널 등록(channelRegistered)</span><br><span class="line"></span><br><span class="line">채널 활성화(channelActive)</span><br><span class="line"></span><br><span class="line">데이터 수신(channelRead)</span><br><span class="line"></span><br><span class="line">데이터 수신 완료(channelReadComplete)</span><br><span class="line"></span><br><span class="line">채널 비활성화(channelInactive)</span><br><span class="line"></span><br><span class="line">이벤트 루프에서 채널 제거(channelUnregistered)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>아마 대부분 메인로직은 데이터 수신~수신완료에 쓰일것이라 보입니다.</p>
</blockquote>
<p>이벤트를 간단히 정리해보겠습니다.</p>
<ul>
<li><code>channelRegistered</code>의 이벤트 발생 시점은 서버와 클라이언트 모두 처음 소켓 채널이 생성할 때 발생하며, 서버의 경우 클라이언트 소켓 채널이 서버 소켓 채널에 등록될 때 다시 발생합니다.</li>
<li><code>channelActive</code>의 이벤트는 서버 또는 클라이언트가 연결한 직후 한 번 수행할 작업을 처리하기에 적합합니다.(예를 들면 Hello Client 라던가…)</li>
<li><code>channelRead</code>와 <code>channelReadComplete</code> 이벤트는 데이터의 수신시 발생하지만 Read는 채널에 데이터가 있을 때 발생하고 Complete는 데이터를 다 읽었을 때 발생합니다.</li>
<li><code>channelInactive</code>가 발생하면 Read가 불가능합니다.</li>
<li><code>channelUnregistered</code>가 발생하면 등록했던 소켓에 대한 이벤트 처리가 불가능합니다.</li>
</ul>
<h3 id="채널-아웃바운드-이벤트"><a href="#채널-아웃바운드-이벤트" class="headerlink" title="채널 아웃바운드 이벤트"></a>채널 아웃바운드 이벤트</h3><p>대부분 클라이언트 객체에서 처리할 것으로 보이는 아웃바운드입니다.<br>요청을 보내거나 데이터 전송, 소켓 닫기 등의 이벤트를 가지고 있습니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50545453-6ce2c600-0c57-11e9-8942-ee94220bf243.png" alt="Outbound"></p>
<p>이벤트를 간단히 정리해보겠습니다.</p>
<ul>
<li><code>bind</code> 이벤트는 서버 소켓 채널에 클라이언트가 연결을 대기하는 IP와 포트가 설정되었을 때 발생합니다. 파라미터 중 <code>SocketAddress</code>로 서버에서 사용하는 IP/포트 정보를 확인 가능합니다.</li>
<li><code>connect</code> 이벤트는 서버에 연결되었을 때 발생합니다. </li>
<li><code>disconnect</code> 이벤트는 연결이 끊어졌을 때 발생합니다.</li>
<li><code>close</code> 이벤트는 소켓 채널의 연결이 닫혔을 때 발생합니다.</li>
<li><code>write</code> 이벤트는 소켓 채널에 데이터가 기록되면 발생합니다.</li>
<li><code>flush</code> 이벤트는 소켓 채널에 대한 flush 메소드가 호출되면 발생한다고 합니다.</li>
</ul>
<h3 id="ChannelHandlerContext"><a href="#ChannelHandlerContext" class="headerlink" title="ChannelHandlerContext"></a>ChannelHandlerContext</h3><p>대부분의 이벤트가 <code>ChannelHandlerContext</code>를 파라미터로 제공하는 것을 볼 수 있습니다. 이 녀석의 경우 채널 파이프라인이나 다른 핸들러의 상호작용을 도와주는 인터페이스입니다.<br>즉, <code>writeAndFlush</code>등의 메서드로 채널에 데이터를 기록하며 <code>close</code> 메소드로 연결종료나 자신이 속한 파이프라인의 동적 수정, 다음 Handler에 통지하는 등 다양한 기능을 수행합니다.</p>
<h2 id="코덱"><a href="#코덱" class="headerlink" title="코덱"></a>코덱</h2><p>우리가 동영상 플레이어를 설치 시 말하는 그 코덱과 의미가 같습니다. 즉, 전송을 보내는/받은 파일을 특정 루틴에 의해 압축,변환 시키고 해제를 시키는 라이브러리 같은 개념으로 생각하면 되겠죠.<br>Netty 에서는 코덱을 통해 데이터-패킷으로 상호 변환을 합니다. 그리고 Netty의 코덱은 템플릿 메소드 패턴을 사용했다고 합니다.(실행순서만 위에서 설정하고 실제 구현은 하위에서)</p>
<p>사용자가 직접 만들 수 있지만 대부분의 프로토콜은 Netty에서 기본제공하므로 가져다가 쓰시는 것을 추천합니다.<br>기본 예제는 io.netty.example 패키지에 포함되어있다고 합니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>이벤트가 참 많네요. 코덱까지 세트로 제공하니 쉽게 데이터를 주고 받을 수 있을 것 같은 느낌입니다.<br>3일차를 마치고 4일차로 가보겠습니다. 점점 양이 많아지는것을 느낍니다.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/29/netty/day3/" data-id="cjq974xu20003oxminpo36l3t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty/day2" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/25/netty/day2/" class="article-date">
  <time datetime="2018-12-24T15:00:00.000Z" itemprop="datePublished">2018-12-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/25/netty/day2/">네티 알아보기 2일차 - 부트스트랩</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2일차를 신나게 달려봅시다.</p>
<h1 id="3장"><a href="#3장" class="headerlink" title="3장"></a>3장</h1><h2 id="프로토콜"><a href="#프로토콜" class="headerlink" title="프로토콜"></a>프로토콜</h2><p>아무래도 통신관련 프레임워크기 때문에 통신 프로토콜을 모를 수도 없어서 간단하게 알아보도록 하겠습니다.</p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>TCP의 경우 연결을 확인하고 메시지를 전송하는 것을 보장하는 특성을 가지고 있습니다.<br>메시지를 받을때마다 받았다는 신호를 보내 서로 전송되었고 받았는지 확인하죠.</p>
<h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><p>UDP는 메시지는 전송하지만 받았는지 전혀 확인하지 않기 때문에 누락, 분실, 메시지 순서를 보장하지 않는 등의 특징을 가지고 있습니다.<br>그럼에도 왜 쓰냐하면 체크하는 과정이 없기 때문에 TCP에 비해 상대적으로 오버헤드가 적고 속도가 빠른 장점이 있습니다.</p>
<h3 id="SCTP"><a href="#SCTP" class="headerlink" title="SCTP"></a>SCTP</h3><p>검색하다가 IBM에서 좋은 정보를 제공하기에 가져왔습니다.</p>
<p>스트림 전송 제어 프로토콜(SCTP)은 TCP와 유사한 연결 지향 프로토콜이지만 UDP와 유사한 메시지 지향 데이터 전송을 제공합니다.<br>일반적으로 SCTP는 안정적이면서도 메시지 지향적인 데이터 전송을 필요로 하는 VoIP(Voice over IP)와 같은 특정 애플리케이션에 대해 더 많은 유연성을 제공합니다. 이런 애플리케이션 범주에 대해 SCTP는 대부분 TCP나 UDP보다 더 적합합니다.</p>
<ul>
<li>TCP는 신뢰 가능하며 엄격한 전송 순서의 데이터 전달을 제공합니다. 신뢰성이 필요로 하지만 순서화되지 않았거나 부분적으로만 순서화된 데이터 전달을 허용하는 애플리케이션의 경우, TCP는 HOL(head-of-line) 블로킹으로 인해 불필요한 지연을 초래할 수 있습니다. 단일 연결 내에 여러 스트림 개념을 사용하는 SCTP는 데이터를 다른 스트림으로부터 논리적으로 분리하는 동시에 하나의 스트림 내에서 엄격한 순서로 전달할 수 있습니다.</li>
<li>SCTP는 바이트 지향인 TCP와는 달리 메시지 지향입니다. TCP의 바이트 지향 특성으로 인해 애플리케이션은 메시지 경계를 유지하려면 고유한 레코드 표시를 추가해야 합니다.</li>
<li>SCTP는 멀티-홈 기능을 사용하여 어느 정도의 결함 허용치를 제공합니다. 호스트는 동일하거나 다른 네트워크에서 둘 이상의 네트워크 인터페이스가 접속된 경우 멀티-홈으로 간주됩니다. 두 개의 멀티-홈 호스트 사이에 SCTP 연관을 설정할 수 있습니다. 이 경우 두 엔드포인트의 모든 IP 주소가 연관 시작 시에 교환됩니다. 이를 통해 각 엔드포인트는 인터페이스 중 하나가 어떤 이유에서이건 작동 중지된 경우 대체 인터페이스를 통해 피어에 연결 가능한 한 남은 연결 기간 동안 이러한 주소를 사용할 수 있습니다.</li>
<li>SCTP는 TCP 및 UDP는 제공하지 않는 추가 보안 기능을 제공합니다. SCTP에서 연결 설정 시 자원 할당은 쿠키 교환 메커니즘을 사용하여 클라이언트의 ID를 검증하기 전까지 지연되어 서비스 거부 공격 가능성을 줄입니다.</li>
</ul>
<h3 id="프로토콜간-차이점"><a href="#프로토콜간-차이점" class="headerlink" title="프로토콜간 차이점"></a>프로토콜간 차이점</h3><p>표 하나로 설명합니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50411940-77f8b900-0847-11e9-89af-4f0dc106a21b.png" alt="차이점(어디서 가져온지 기억이 잘..)"></p>
<h2 id="부트스트랩이란"><a href="#부트스트랩이란" class="headerlink" title="부트스트랩이란?"></a>부트스트랩이란?</h2><p>제가 아는 웹 프론트엔드 프레임워크가 아니라 Netty에서 가장 처음 수행되는 부분으로써 동작과 설정을 지정하여 가장 기본이 되는 부분이라 합니다.<br>API Doc의 Bootstrap 클래스에서는 다음과 같이 얘기하고 있습니다.</p>
<blockquote>
<p>부트스트랩은 채널을 쉽게 사용할 수 있도록 해주는 것</p>
</blockquote>
<h3 id="구조"><a href="#구조" class="headerlink" title="구조"></a>구조</h3><p>논리적 구조는 다음과 같습니다.</p>
<ul>
<li>소켓 모드 및 I/O종류</li>
<li>이벤트 루프</li>
<li>채널 파이프라인 설정</li>
<li>소켓 주소 및 포트 등의 옵션 설정</li>
</ul>
<p>빌더 패턴을 사용하여 선택적인 옵션을 파악하기 쉽도록 추가할 수 있습니다.</p>
<h3 id="시작해보기"><a href="#시작해보기" class="headerlink" title="시작해보기"></a>시작해보기</h3><p>가장 처음에 작성했던 에코 서버 코드를 가져와서 조금 수정 후 확인해봅시다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup loopGroup = new NioEventLoopGroup(1);</span><br><span class="line">EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">bootstrap.group(loopGroup, workerGroup)</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                    protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                        pipeline.addLast(new EchoServerHandler());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">ChannelFuture f =bootstrap.bind(8888).sync();</span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></table></figure>
<p>먼저 <code>new NioEventLoopGroup()</code>를 보면 생성자의 인수가 없는데 이럴 경우 사용할 스레드 수를 하드웨어의 스레드 수로 한다고 합니다.<br>스레드 수는 하드웨어가 가지고 있는 CPU 코어 수의 2배를 사용한다 합니다. 4C 8T의 경우 하드웨어(CPU)에서 지원하는 8T의 두 배인 16개죠. 그리고 loopGroup 변수는 사용할 스레드 수를 1개로 지정하였습니다.<br><code>ServerBootstrap.group()</code> 메소드는 NioEventLoopGroup을 인수로 받는데 첫번째는 연결에 사용할 스레드이고 두 번째 인수는 연결된 소켓에 대한 I/O처리를 담당합니다.<br>저는 연결은 한번만 하고 끝나니 하나만 사용했고, I/O의 경우 어떻게 몇개가 들어올지 모르니 여러개의 스레드를 사용했다고 생각했습니다.<br><code>.channel()</code> 메소드는 API명세에 따르면 Channel 인터페이스를 구현한 객체나 채널팩토리를 사용할 수 있고 이 예제에서는 NioServerSocketChannel 클래스를 설정했기 때문에 Nio모드를 사용합니다.<br><code>.childHandler</code> 메소드는 API에 채널에서 요청이 왔을 때 제공할 ChannelHandler를 설정합니다.</p>
<p>연결 방법을 바꾸고 싶으면 <code>.channel()</code> 부분에서 제공하는 클래스를 변경하면 입출력 모드를 쉽게 바꿀 수 있도록 Netty에서는 제공하고 있습니다.<br>지원하는 클래스는 다음과 같습니다.(안보이면 클릭하셔서 보시기 바랍니다)</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50411468-8ba22080-0843-11e9-920e-54fe248d67a7.png" alt="지원클래스 with Netty"></p>
<p>이 중 Epoll은 *nix에서 동작한다고 합니다.</p>
<h3 id="부트스트랩-내-간단한-API-소개"><a href="#부트스트랩-내-간단한-API-소개" class="headerlink" title="부트스트랩 내 간단한 API 소개"></a>부트스트랩 내 간단한 API 소개</h3><p>channelFactory - 소켓 입출력 모드 설정</p>
<p>channel 메소드와 동일한 기능을 수행합니다.</p>
<p>handler - 이벤트 핸들러 설정</p>
<p>소켓 채널에서 발생한 이벤트를 수신하여 처리합니다.</p>
<p>childHandler - 소켓 채널의 데이터 가공 핸들러 설정</p>
<p>소켓 채널로 송수신 되는 데이터를 가공하는 핸들러입니다. ChannelHandler 인터페이스를 구현한 클래스를 인수로 입력 가능합니다.</p>
<p>option - 소켓의 옵션을 설정합니다.</p>
<p>소켓의 옵션이란 소켓의 동작 방식을 지정하는 것을 말합니다.<br>소켓 옵션은 어플리케이션의 값을 바꾸는 것이 아니라 커널에서 사용되는 값을 변경한다는 의미입니다.</p>
<p>childOption - 소켓의 옵션을 설정합니다.</p>
<p>option 메소드는 서버의 옵션을, childOption 메소드는 클라이언트의 옵션을 설정합니다.</p>
<p>group - 이벤트 루프 설정</p>
<p>소켓 채널의 이벤트 처리를 위한 루프 객체를 생성합니다.<br>클라이언트는 단 하나의 이벤트 루프만 설정할 수 있습니다.</p>
<p>channel - 입출력모드 설정</p>
<p>서버 - 클라이언트의 입출력 채널을 설정합니다.<br>서버와 클라이언트는 설정할 수 있는 입출력 모드가 상이합니다.</p>
<h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>부트스트랩으로 서버와 클라이언트에서 각자 연결하고 처리할 수 있는 방법을 쉽게 제공합니다.<br>여러가지 준비해 놓았으니 상황에 맞춰 가장 최적의 연결방법을 찾아서 해야 겠지요…</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/25/netty/day2/" data-id="cjq974xtz0001oxmi1jlkodv8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-netty/day1" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/24/netty/day1/" class="article-date">
  <time datetime="2018-12-24T07:00:00.000Z" itemprop="datePublished">2018-12-24</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Netty/">Netty</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/24/netty/day1/">네티 알아보기 1일차 - 기본 환경설정</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>그동안 사놓고 안읽어봤던 자바 네트워크 소녀 Netty를 익히면서 쓰는 글입니다.<br>github blog + hexo로 만들어보는 첫번쨰 블로그이기도 하죠</p>
<h1 id="1장"><a href="#1장" class="headerlink" title="1장"></a>1장</h1><h2 id="네티란"><a href="#네티란" class="headerlink" title="네티란?"></a>네티란?</h2><p><code>Netty는 유지 보수 가능한 높은 성능 프로토콜 서버 &amp; 클라이언트를 빠르게 개발할 수 있는 비동기적인 이벤트 기반 네트워크 어플리케이션 프레임워크</code>라고 합니다.</p>
<h2 id="시작해보기"><a href="#시작해보기" class="headerlink" title="시작해보기"></a>시작해보기</h2><p>1탄으로 Java 1.8 + maven 환경에서 작업해 보겠습니다. (추후에 생각나면 스프링도…)</p>
<p>라이브러리를 다운받아서 직접 lib 폴더에 넣으셔도 되지만 저는 그냥 maven으로 하겠습니다.</p>
<p>가장 먼저 프로젝트를 만들고 pom.xml에 netty 레포지토리 태그를 집어넣습니다.</p>
<p>개발환경은 5.0 alpha가 있지만 4.1 final버전으로 하겠습니다.</p>
<p>pom.xml에 다음과 같이 넣어주세요.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.1.32.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>그리고 maven install을 하셔서 lib에 netty.jar가 정상적으로 들어있는지 확인해주세요.</p>
<p>intellij IDEA를 예로 들어서 정상적으로 라이브러리가 들어왔는지 확인 하려면 External Libraries에 들어있는지 확인하시면 되겠습니다.</p>
<p><img src="https://user-images.githubusercontent.com/20100284/50393342-fd716000-0798-11e9-9b1d-3aa65d041566.png" alt="라이브러리 확인"></p>
<p>그럼 이제 Netty 프레임워크로 책내용을 따라서 만들어보겠습니다.</p>
<h2 id="에코서버-만들기"><a href="#에코서버-만들기" class="headerlink" title="에코서버 만들기"></a>에코서버 만들기</h2><h3 id="일단-무조건-따라쳐봅시다"><a href="#일단-무조건-따라쳐봅시다" class="headerlink" title="일단 무조건 따라쳐봅시다."></a>일단 무조건 따라쳐봅시다.</h3><p>서버를 만들어 봅시다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class EchoServer &#123;</span><br><span class="line"></span><br><span class="line">    public void echo() throws InterruptedException &#123;</span><br><span class="line">        EventLoopGroup loopGroup = new NioEventLoopGroup();</span><br><span class="line">        EventLoopGroup workerGroup = new NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ServerBootstrap bootstrap = new ServerBootstrap();</span><br><span class="line">            bootstrap.group(loopGroup, workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        protected void initChannel(SocketChannel socketChannel) throws Exception &#123;</span><br><span class="line">                            ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">                            pipeline.addLast(new EchoServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture f =bootstrap.bind(8888).sync();</span><br><span class="line"></span><br><span class="line">            f.channel().closeFuture().sync();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            loopGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>따라치다보면 같은 클래스 명을 가진 라이브러리를 만날 수도 있습니다만…(안만날수도있고요) 무조건 io.netty.이하로 선택합니다.</p>
<p>살펴보니 EventLoopGroup이라는 것을 만들어서 ServerBootStrap이라는 것에 집어넣습니다.<br>채널에 클래스를 뭔가 하나 담고 밑에서 일할 핸들러를 하나 만들고 파이프라인이라는 것을 만들어서 마지막에 핸들러를 하나 담았습니다.<br>그리고 8888 포트를 만들어서 sync메소드로 동기화같은 작업을 하나 봅니다.</p>
<p>당연히 실행은 new EchoServer.echo()로 하겠지요.</p>
<p>이번에는 파이프 라인에 들어갈 핸들러를 만들어 보겠습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        String readMsg = ((ByteBuf)msg).toString(Charset.defaultCharset());</span><br><span class="line">        System.out.println(&quot;수신한 문자열 [&quot;+readMsg + &quot;]&quot;);</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        super.exceptionCaught(ctx, cause);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이벤트 기반의 프레임워크라고 소개했듯이 핸들러를 통해 이벤트에 맞춰 어떻게 작업할 것인지 선택합니다.<br>여기서는 ChannelInboundHandlerAdapter를 상속받아서 이벤트 콜백을 설정합니다.<br>channelRead와 모두 완료됐을때 호출될 channelReadComplete를 오버라이드 해서 완료했을때의 이벤트를 설정합니다.</p>
<p>그 다음 자바를 실행하고 telnet으로 접속해서 날려보면 자바 콘솔창에 확인이 가능합니다.</p>
<blockquote>
<p>한글자씩 안찍히고 엔터키를 입력시 입력한 문자가 그대로 텔넷 클라이언트에 한번 더 찍힌다면 연결 종류가 Raw라서 그렇다고 한다. 리눅스 쓰는데 해당 증상이 나타나버렸습니다…</p>
</blockquote>
<h2 id="에코-클라이언트-만들기"><a href="#에코-클라이언트-만들기" class="headerlink" title="에코 클라이언트 만들기"></a>에코 클라이언트 만들기</h2><h3 id="같이-만들어-봅시다"><a href="#같이-만들어-봅시다" class="headerlink" title="같이 만들어 봅시다."></a>같이 만들어 봅시다.</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class EchoClientHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ByteBuf msgBuffer = Unpooled.buffer();</span><br><span class="line">        byte[] sendMsgByte = &quot;반가워요&quot;.getBytes();</span><br><span class="line">        msgBuffer.writeBytes(sendMsgByte);</span><br><span class="line">        ctx.writeAndFlush(msgBuffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span><br><span class="line">        String readMsg = ((ByteBuf)msg).toString(Charset.defaultCharset());</span><br><span class="line">        System.out.println(&quot;수신한 문자열 [&quot;+readMsg + &quot;]&quot;);</span><br><span class="line">        ctx.write(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>책에 나온 차이점이라면 처음에 채널이 연결되었을때 이벤트를 추가해준것 밖에 없습니다.<br>실행해봅시다.</p>
<h1 id="2장"><a href="#2장" class="headerlink" title="2장"></a>2장</h1><h2 id="인바운드-아웃바운드"><a href="#인바운드-아웃바운드" class="headerlink" title="인바운드, 아웃바운드"></a>인바운드, 아웃바운드</h2><h3 id="인바운드란"><a href="#인바운드란" class="headerlink" title="인바운드란?"></a>인바운드란?</h3><p>당사자 입장에서 들어오는 것</p>
<h3 id="아웃바운드란"><a href="#아웃바운드란" class="headerlink" title="아웃바운드란?"></a>아웃바운드란?</h3><p>당사자 입장에서 나가는 것</p>
<h3 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h3><p>내가 친구에게 <code>안녕</code>이라는 메시지를 보냈다면, 친구입장에서는 <code>안녕</code>이라는 메시지가 인바운드 된 것이고 나에게는 <code>안녕</code>메시지가 아웃바운드 된 것이다.</p>
<h2 id="동기-비동기"><a href="#동기-비동기" class="headerlink" title="동기, 비동기"></a>동기, 비동기</h2><p>이 것은 굳이 Netty가 아니더라도 수 많은 곳에서 사용합니다. 사전에 정의된 해설은 다음과 같습니다.</p>
<h3 id="동기"><a href="#동기" class="headerlink" title="동기"></a>동기</h3><p>데이터 전송에 있어서 일정 클록 신호에 맞추어 데이터의 송수신을 하는 방법으로 통신을 시작할 때, 데이터의 최초에 통신 속도와 통신 방법을 식별하기 위한 동기 캐릭터(synchronous character)를 첨부하여 송신하는 방법</p>
<h3 id="비동기"><a href="#비동기" class="headerlink" title="비동기"></a>비동기</h3><p>통신을 하는 양쪽 장치가 데이터를 주고받을 때 일정한 속도를 유지하는 것이 아니라, 약정된 신호에 기준하여 동기를 맞추는 통신 방법</p>
<h2 id="블로킹-논블로킹"><a href="#블로킹-논블로킹" class="headerlink" title="블로킹, 논블로킹"></a>블로킹, 논블로킹</h2><p>소켓통신에 주로 쓰이는 용어입니다. 물론 다른곳에도 쓰일수도 있지요.</p>
<h3 id="블로킹"><a href="#블로킹" class="headerlink" title="블로킹"></a>블로킹</h3><p>요청한 작업이 완료되거나 에러가 발생해서 끝날 때 까지 응답을 돌려주지 않는 방법</p>
<h3 id="논-블로킹"><a href="#논-블로킹" class="headerlink" title="논 블로킹"></a>논 블로킹</h3><p>작업 완료 여부와 상관없이 결과를 돌려주는 방법</p>
<p>블로킹의 경우 관공서 민원실이나 은행 업무처리정도로 생각하면 쉬울 것 같고 논 블로킹의 경우 공항이나 티켓교환소의 인포메이션 센터 정도로 생각하면 되지 않을까 싶습니다.<br>은행이나 관공서의 경우 1:1로 고객의 모든 일이 끝날때 까지 붙어서 처리하고 인포메이션 센터는 나에게 정보를 알려주고 내가 이해하는 동안 다른사람이 물어보면 바로 그 사람에게 응답을 해주고 내가 다시 질문 할 경우 알려주는 등 동시에 여러가지 여러명에게 업무를 한다고 생각하면 쉬울 것 같습니다.</p>
<h2 id="이벤트기반-프로그래밍"><a href="#이벤트기반-프로그래밍" class="headerlink" title="이벤트기반 프로그래밍"></a>이벤트기반 프로그래밍</h2><p>내가 설정한 이벤트가 발생하면 이벤트에 직접 등록한 루틴이 실행되는 방식입니다.<br>즉, 이벤트 발생 -&gt; 이벤트를 받아서 처리할 것이 있는지 검색 -&gt; 실행 순이겠죠.</p>
<p>Netty에서는 ChannelInboundHandlerAdapter로 여러 이벤트 기반 프로그래밍을 지원합니다.<br>여기서 채널은 소켓 채널입니다.</p>
<h2 id="Future-java"><a href="#Future-java" class="headerlink" title="Future(java)"></a>Future(java)</h2><p>간단하게 알아보면 어떠한 로직을 처리했을때 처리한 값을 받아 작업하는 방식입니다. 비동기에서 쓰이며 결과값을 얻을 때 까지 필요에 의해 블록처리가 될 수 있습니다.<br>작업이 정상적으로 완료/취소 되었는지 확인을 위해 방법을 제공하며 성공적으로 수행시 <code>get</code> 취소했을경우 <code>cancel</code> 메소드로 수행됩니다.(인터페이스 기준)</p>
<p>여기서 1일차를 마치겠습니다. 2일차에서 만나요.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/24/netty/day1/" data-id="cjq974xtv0000oxmisvaq552o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-about/about" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/12/23/about/about/" class="article-date">
  <time datetime="2018-12-23T08:00:51.000Z" itemprop="datePublished">2018-12-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/About/">About</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/12/23/about/about/">about</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="나는-누구인가요"><a href="#나는-누구인가요" class="headerlink" title="나는 누구인가요?"></a>나는 누구인가요?</h2><p>쓸데없이 나이만 먹은 남자입니다. 취미는 게임과 컴퓨터 하드웨어 정보수집이예요.</p>
<h3 id="간단한-프로필"><a href="#간단한-프로필" class="headerlink" title="간단한 프로필"></a>간단한 프로필</h3><p>출생 : 1990년생</p>
<h3 id="일하면서-해봤던-것"><a href="#일하면서-해봤던-것" class="headerlink" title="일하면서 해봤던 것"></a>일하면서 해봤던 것</h3><p>frontend : HTML, CSS(with LESS), Javascript(with jQuery)<br>backend : JAVA(Spring), Classic ASP, ASP.NET &amp; PHP(문자메시지 모듈만 연동해본 수준)<br>Database : oracle, mysql<br>Server : Apache-Tomcat, IIS, AWS(EC2, S3)</p>
<p>##스터디에서 해봤던 것<br>Javascript(~ES6), Node.JS</p>
<h3 id="경력사항"><a href="#경력사항" class="headerlink" title="경력사항"></a>경력사항</h3><ol>
<li>SI회사(2015.11 ~ 2018.02)</li>
<li>인테리어 관련 쇼핑몰(2018.07 ~ 2018.11)</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/12/23/about/about/" data-id="cjq974xu30004oxmi1knalpin" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/About/">About</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Netty/">Netty</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">12월 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/29/netty/day3/">네티 알아보기 3일차 - 채널 파이프라인 + 코덱</a>
          </li>
        
          <li>
            <a href="/2018/12/25/netty/day2/">네티 알아보기 2일차 - 부트스트랩</a>
          </li>
        
          <li>
            <a href="/2018/12/24/netty/day1/">네티 알아보기 1일차 - 기본 환경설정</a>
          </li>
        
          <li>
            <a href="/2018/12/23/about/about/">about</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 halim j<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>